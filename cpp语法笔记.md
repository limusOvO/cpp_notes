# 1. 常规语法

## 1.1 `const`用法

### 1.1.1 修饰指针

* `const int* p` 或 `int const* p` → 指针指向的内容不可修改（pointer to const int）
* `int* const p` → 指针本身不可修改（const pointer to int）

```C++
const int* a = &x;       // [1] 指针指向内容不可修改，指针可改
int const* a = &x;       // [2] 同 [1]，内容不可改
int* const a = &x;       // [3] 指针不可改，内容可改
const int* const a = &x; // [4] 指针不可改，内容不可改
```

### 1.1.2 修饰函数

**成员函数后加` const`** → 表示该成员函数不会修改对象的成员变量（`this` 指针是 `const` 类型）。

**静态成员函数或非成员函数** → 不能在函数后加 `const`，因为它们没有 `this` 指针。

**特殊情况** → 成员变量如果要在` const `函数里修改，可加 `mutable` 修饰。

### 1.1.3 修饰返回值

- **返回类型前 `const`** → 修饰返回值
- **C++11 以后**：
  - `constexpr` → 编译期常量
  - `consteval` → 强制编译期求值（C++20）

### 1.1.4 修饰普通变量

定义不可修改的常量，提高代码安全性。

### 1.1.5 修饰函数参数

防止函数修改传入对象（尤其大对象用引用或指针传递时）



## 1.2 拷贝构造和赋值运算符

重点：

​	最本质的区别在于对象的状态。

​	拷贝构造函数是一个对象从无到有被创建（初始化）时调用的；

​	而赋值运算符是在两个都已经存在的对象之间，将一个对象的值赋值给另一个对象时调用的。

```C++
A a;
A b = a;  //调用拷贝构造（虽然是=号，但在初始化0
A c;
c = a; //调用赋值运算符（c已经存在）
```

面试回答方式：

	1. 拷贝构造用于对象初始化（T a = b ;), 对象此时还未分配资源。
	1. 赋值运算符用于修改已存在的对象的值（a = b); 对象此时可能已经持有资源。

在实现方面，有三个关键点我会注意下：

​	第一是自赋值检测： 在`operator=`中，首先要判断`&other!=this`,防止自身资源后再去拷贝，导致未定义行为。

​	第二是返回值： 赋值运算符应该返回*this的引用，已支持a = b = c 这样的链式调用。

​	第三是资源管理：如果我需要手动管理资源（如new/delete），我通常会同时实现拷贝构造、赋值运算和析构函数。在现代C++中，使用Copy-and-Swap（拷贝并交换）技术来实现赋值，这样能更好的保证异常安全。



补充： Copy-and-Swap 即利用拷贝构造函数创建一个临时副本，然后将副本与当前对象（*this）的数据进行swap， 这样利用了栈对象的析构函数自动处理资源释放，简洁又安全。 



## 1.3 深拷贝和浅拷贝

*   浅拷贝是编译器的默认行为。它只是简单的将源对象的所有成员变量的值，按位复制给目标对象。如果成员变量是指针，浅拷贝只复制指针变量本身（也就是内存地址), 导致两个对象的指针指向同一块堆内存。
*   深拷贝不仅复制成员变量的值，对于指针成员，它会申请一段新的内存，并将原有的数据复制过去。两个对象虽然数据内容相同，但它们指向的内存地址是独立的，互不干扰。

面试问题：

 1.    为什么浅拷贝会崩溃？

       如果类中管理了动态内存（例如char* buffer），使用默认的浅拷贝是非常危险的。

       当两块内存指向同一块内存时：

       *   修改冲突：修改对象A的数据，对象B也会莫名其妙被修改。
       *   Double free： 这是最严重的。当对象A析构时，它释放了那块内存；紧接着对象B析构时，试图再次释放同一块已经无效的内存，程序会直接崩溃（core dump).

 2.    在现代C++中如何手动避免深浅拷贝带来的繁琐和错误？

       *   使用标准容器（如std::vector，std::string)，它们内部已经实现了深浅拷贝，自动管理内存。
       *   使用智能指针（如std::unique_ptr禁止拷贝，或std::shared_ptr共享所有权), 从而避免裸指针带来的深浅拷贝陷阱。

 3.    如果你实现了深拷贝（拷贝构造），你还需要实现什么？

       ​        Rule of Three（三法则）。如果你定义了析构函数，拷贝构造函数或拷贝赋值运算符中的任意一个，你通常也需要定义另外两个。如果析构函数在释放自己管理的资源了(例如new/delete；malloc/free；fopen/fclose；socket/close；互斥锁、句柄、文件描述符)，那就必须定义拷贝构造（深拷贝），拷贝赋值（深拷贝+自释放）。

 4.    深拷贝有什么确定？

       性能开销。频繁的malloc/new和内存复制非常耗时。这也是为什么C++11引入了移动语义，通过“移动”资源来代替昂贵的“深拷贝”。

## 1.4 虚函数，多态，`vtable`(虚函数表)

C++的多态分为静态多态（编译时决定，如函数重载和模板）和动态多态（运行时决定）。 虚函数属于动态多态，它允许通过基类的指针或引用来调用派生类的成员函数。

（然后讲解一下vtable和vptr的关系）

编译器会为每个拥有虚函数的类都创建一个虚函数表（vtable），这是一个存储类成员函数地址的数组。

而每个对象实例中，编译器会隐式添加一个指针，称为虚函数指针（ptr），它指向该类对应的vtable。

当我们通过基类指针调用虚函数时，程序会经过以下步骤：

	1. 根据对象的vptr找到类的vtable
	1. 根据函数在表中的偏移量（offset）找到具体的函数地址。
	1. 跳转到该地址执行代码。

内存布局上：

​	一个含有虚函数的类，其对象会比普通类多出一个指针的大小（64位上是8字节），通常这个vptr位于对象内存布局的最前端（或者最后端，取决编译器实现），以便快速寻址。

多态的代价：

1.   空间开销：每个类一个vtable， 每个对象一个vptr
2.   时间开销： 多了一个指针间接寻址的开销；同时由于是运行时跳转，编译器很难对虚函数进行内联优化，这在高性能场景下是一个考虑因素。

面试回答：

​	C++的动态多态主要通过虚函数表和虚函数指针来实现。

​	简单来说，当一个类声明了虚函数，编译器就会为了这个类声称一张vtable，里面按顺序存放着虚函数的地址。当子类重写了父	类的虚函数时，子类vtable中对应位置的地址就会被替换为子类函数的地址。

​	在实例化对象时，每个对象头部会自动包含一个vptr，当我们通过基类指针调用函数时，系统不会在编译时硬编码跳转地址，而	是在运行时通过vptr找到vtable，再根据索引取出真正的函数地址进行调用。

​	这种机制实现的“延迟绑定”，但也会带来一些额外开销，比如vptr的占用空间以及无法内联导致的时间损耗，此外在多重继承	下，一个对象可能有多个vptr，对应的布局也会更加复杂。



补充：	

​	构造函数可以是虚函数吗？（不可以，因为构造时vptr还没有初始化完成）

​	析构函数为什么要设置为虚函数？（防止基类指针指向子类对象时，析构只释放基类部分导致内存泄漏。）

​	虚函数表是每个对象一份吗？（不是，是每个类一份，所有对象共享同一张表，但是每个对象有自己的指针）

​	

## 1.5 内存管理 `new/delete` 与 `malloc` 与 `free`的区别

1.   主要区别是对象生命周期的管理。

​		new在分配内存后，会自动调用对象的构造函数进行初始化；而delete在释放内存前，会自动调用析构函数。

​		malloc和free仅仅是单纯的内存分配与释放，不会执行任何初始化或清理代码。

2.   类型安全与返回类型：

​		new是类型安全的，返回的是具体类型的指针，不需要显示强转。

​		而malloc返回的是void * ，在C++中必须进行强制强制类型转换。此外，new不需要手动计算内存的大小（编译器会根据类		型自动推导），而malloc需要手动传入sizeof（T）

3.   错误处理方式

     ​      当内存分配失败后，默认情况下new会抛出std::bad_alloc异常，这符合现代C++的错误处理范式。

     ​      而malloc失败后只会返回NULL，这意味着使用malloc后必须检查返回值，而使用new则可以通过异常捕获机制集中处理错误。

4.   可定制性

     ​	operator new 是可以被重载的，我们可以为指定的类定制内存分配策略，比如使用内存池。

     ​	此外我们还可以通过set_new_handler指定内存分配失败时的回调函数，这些在malloc中都是无法实现的。

面试回答：

​	简单来说，new/malloc是C++的运算符，而malloc/free是c语言的标准库函数。

​	他们最本质的区别是new会触发构造函数，delete会触发析构函数。在C++编程的过程中，这对于确保对象正确初始化和资源的正确释放非常重要。

​	从安全角度讲，new是类型安全的，它知道它创建的是什么类型，不需要我们手动计算sizeof或进行void*强制转换，而且，当内存耗尽时，new默认会抛出异常，而不是返回null，这更有利于我们编写完善的错误处理代码。

​	new还支持一些高级特征，比如可以通过定位new在预分配的内存上构造对象，或者重载operator new来实现自定义的内存池管理。

补充：

	1. 既然new更好，那么malloc在C++中还有用武之地吗？（在与C库交互、实现底层内存池、或者需要realloc扩展内存大小是可能用到）
	1. 如果malloc分配了内存，可以用delete释放吗？（不可以，行为是未定义的（Undefined Behavior），必须配对使用，new[]配delete[],malloc配free，new配delete



## 1.6 左值与右值， 左值引用与右值引用

*   左值： 有名字、有地址、生命周期持久的对象（核心：可取地址）
*   右值：无名、临时的、即将销毁的对象（核心：不可取地址，或者允许被窃取资源）
*   左值引用(T&)：给左值起别名，避免拷贝
*   右值引用(T&&): 专门绑定在右值上，用于实现移动语义。

左值与右值的判断标准是什么？

​	看能不能对它取地址（&），能取地址通常是左值（例如变量名a，解引用指针*p）

​	如果不能取地址，通常是右值，（例如字面量10，临时变量func()的返回值，或者表达式x + y 的结果).

右值引用的引入意义： 移动语义（为什么？）

​        在C++11之前，如果有一个临时的重型对象（例如一个存储了100万个数据的std::vector), 赋值给另一个变量时，只能深拷贝，	非常浪费性能。右值引用的出现，让我们能识别出“这是一个即将销毁的临时对象”。 通过右值引用，我们能直接窃取它内部的资源（例如指针），而不是赋值数据，这就是移动构造和移动赋值的基础。

关键区别： 所有权与资源

*   左值引用： 是共享的视角，我指向你，我们一起用，但我不敢随意动你的内部资源，因为你还要用。
*   右值引用：是“窃取”视角，既然你马上就要销毁了，那我直接把你持有的内存指针拿过来用，把你的指针置空即可。

面试问题：	

 1.    Std::move 做了什么？（std::move 不移动任何东西，他也不产生代码。它仅仅是一个强制类型转换（cast），把一个左值强制转换成右值引用，告诉编译器：”这个对象我不想要了，你可以把它的资源拿走“）

 2.    右值引用类型的变量，是左值还是右值？

       （这是一个经典误区，例如void function(MyClass&& x){}. // 本身是一个左值！虽然他的类型是右值引用。）

       因为x在函数体内有名字、可以取地址、所以它变成了左值。如果要把它往下传递给别的函数并保持移动语义，必须使用std::move(x)或std::forword。

 3.    什么是万能引用？它和右值引用的区别是什么？

          设计模板的`template<typename T> void f(T&& param)`时，它既能接左值也能接右值，配合std::forward 实现完美转发。

面试回答范例：

​	简单来说，左值和右值的核心区别在于生命周期和身份。

​	左值是指那些有特定名字、在内存中有确定存储地址的对象。我们可以对左值取地址，它的生命周期超出当前表达式。右值通常	是值那些临时的、没有名字的、即将销毁的对象，比如字面量或函数返回的临时变量。

​	引入右值引用（&&）的核心目的是为了实现移动语义。

​	在C++11之前，我们将一个临时对象赋值给另一个对象时，必须进行深拷贝，这对于大量堆内存的容器（如vector，string）来	说开销很大。

​	有了右值引用后，我们可以通过重载移动构造函数，直接“窃取”那个临时对象内部持有的资源（比如指针），而不需要重新分配	内存和复制数据。这极大的提高了C++的性能。

​	另外std::move()的作用就是把一个左值强制转换为右值引用，从而触发这个移动机制。

## 1.7 Lambda 捕获方式 `[=]` `[&]`

*   `[=]`: 按值捕获，相当于拍了一张快照
*   `[&]`：按引用捕获，相当于建立了一个链接

只读性：`[=]`默认是const的，想要修改需要加`mutable`

悬空引用：`[&]`最致命的坑

底层实现：Lambda本质上是一个仿函数对象。

1.   `[=]`按值捕获

     `[=]`表示将外部所有用到的变量，拷贝一份到lambda内部。这个拷贝发生在lambda定义的那一刻，而不是调用的时候。默认情况下，这些拷贝在lambda内部是只读的，如果想修改就必须加上`mutable`关键字

2.   `[&]`按引用捕获

​	`[&]`表示Labmda内部使用的是外部变量的引用。意味着Labmda内部对变量的修改，会直接影响到外部的变量。他没有拷贝开

​	销，效率更高，但是它带来了一个巨大的风险： 生命周期问题。

3.   悬空引用

     使用`[&]`时必须非常小心。如果Labmda的生命周期比它捕获的变量更长（例如Labmda被当作一个回调函数返回或者传递到了其他的线程），那么当Labmda执行时，外部变量可能已经销毁了，这是访问它就会导致程序崩溃。

面试回答范例：

​	这两种方式决定了Labmda表达式形成的闭包如何持有外部变量。

​	`[=]`是按值捕获。相当于在Labmda定义时，把外部变量拷贝了一份存到闭包对象里。默认情况下，为了保证函数式编程的副作	用最小，这些拷贝是const的，不能修改。如果非要修改这份副本，需要加mutable关键字。它的优点是安全，不用担心外部变量销	毁后Lambda变成野指针，缺点是有拷贝开销。

​	`[&]`是按引用捕获。 相当于Labmda内部持有外部变量的引用。它的优点是效率高（没有拷贝）且能同步修改外部状态。但它最	大的风险在于生命周期：如果Lambda被延后执行（例如放入线程池或者作为返回值），而原本的栈变量已经释放了，就会导致“悬空	引用”的严重错误。

​	所以在涉及到异步调用或返回Lambda时，我会比较谨慎的使用`[&]`

补充：

1.   Labmda到底是个什么东西？

​	Lambda在编译器眼里，其实就是一个匿名类。

​		`[=]`相当于在这个类定义了成员变量，并在构造函数里把外部变量的值复制给成员变量。

​		`[&]`相当于在这个类里面定义了引用类型的成员变量（或者指针），指向外部变量。

2.   如果在类的成员函数里写Lambda，用`[=]`会捕获到什么？

       陷阱： 很多以为`[=]`会拷贝类的成员变量。

       实际上，`[=]`捕获的是this指针。在类的成员函数里使用`[=]`,实际上是按值捕获了this指针，这意味着如果你在Lambda里使用了类的成员变量，实际上是通过this->member访问的，这依然是引用语义！如果对象被销毁了，Lambda再去访问成员变量依然会崩溃。这是C++中一个非常隐蔽的坑。

## 1.8 移动语义 vs 拷贝语义

*   拷贝语义：复制资源。就像符印一份文件，你有你的，我有我的，互不影响。
*   移动语义：转移资源所有权。就像把文件原件给你，我手里就没有。

性能差异：

*   拷贝需要内存分配、拷贝数据、开销大。
*   移动只是指针的赋值，不涉及内存，开销极小。

拷贝语义：

​		拷贝语义是C++98以来的传统行为。当把一个对象赋值给另一个对象时，默认进行深拷贝。意味着： 我们需要申请新的堆		内存，然后把源对象的数据一点点复制过去。这是安全的，因为两个对象完全独立，但对于大对象来说，效率很低。

移动语义：

​		移动语义是C++11引入的优化。它针对的是右值（即将毁灭的临时对象），既然源对象马上要挂了，我们不需要费劲的去复		制它的资源，直接把它的资源手柄（如指针，文件句柄）’抢‘ 过来就行。

​		实际上就是把目标对象的指针指向源对象的内存，然后把源对象的指针置为nullptr。 这个过程不涉及任何的内存分配和大

​	规模数据搬运。

回答范例：

​	这两者的核心区别在与对资源（如堆内存）的处理方式。

​	拷贝语义致力于创建一个独立的副本。它要求重新分配新的资源并将数据复制过去。这保证了源对象和新对象互补干扰，但是代	价是昂贵的内存分配和数据复制时间，特别是对像std::vector和std::string这样的大容器。

​	移动语义则是为了性能而生。它不是复制资源，而是转移资源的所有权。当我们知道源对象是一个右值（比如临时对象时), 我们	可以通过移动构造函数或移动赋值运算符，直接接管源对象的内存指针，并将源对象的指针置空（防止析构时double free).



补充：

 1.    移动后源对象置为空，那么移动后的源对象还能用吗？

       经典的陷阱，标准规定它必须处于“有效但未指定的状态”， 不能去读取，但是可以安全的进行销毁，或者进行重新复制。但是不能使用它之前的状态，因为它的资源已经被偷走了。

 2.    什么时候编译器会生成移动构造函数？

       只有当你没有声明任何指定的拷贝构造、拷贝赋值、析构函数时，编译器才会尝试生成默认的移动操作











## 1.9 智能指针  `unique_ptr / shared_ptr/weak_ptr`



## 1.10 override / final



## 1.11 explicit 防隐式类型转换





## 1.12 `constexpr` 函数增强



## 1.13 std::optional / std::variant / std::any





## 1.14 `inline` 全局变量



## 1.15 结构化绑定





## 1.15 string_view vs string





## 1.16` [[nodiscard]]`





##  1.17 fold 表达式





## 1.18 `if constexpr`





## 1.19  static关键字在C++中有哪些作用？

一般就三种。修饰局部变量，全局变量，类成员（变量/函数）。





# 2. 编程规范

## 2.1 类型安全

 **程序在编译期或运行期尽量保证数据类型不被误用或意外转换**

``` c++
int a = 10;
double b = 3.14;

a = b; // 隐式转换，可能丢失精度 → 不完全类型安全
```

**C++ 类型安全机制：**

- **强类型检查**：C++ 不允许把指针随意赋值给其他类型（需要显式转换）。
- **const 修饰**：防止修改不该修改的类型数据。
- **enum class**（C++11）：强类型枚举，不允许隐式转 int。

```c++
enum Color { RED, GREEN, BLUE }; 		// 老式 enum，可以隐式转 int
enum class Color2 { RED, GREEN, BLUE }; // 类型安全，不可隐式转 int
```



## 2.2 浮点数比较的特殊方法

浮点数（`float` / `double`）存在精度问题，不宜直接用 `==` 比较：

```
double a = 0.1 + 0.2;
double b = 0.3;

if (a == b) { /* 不可靠 */ }
```

### 正确做法：使用 **误差范围 epsilon**

```
#include <cmath>
const double EPSILON = 1e-9;

if (std::abs(a - b) < EPSILON) {
    // a 与 b 可认为相等
}
```

- EPSILON 表示容忍的最小误差
- 对浮点数比较要使用绝对误差或者相对误差
- C++17 可以用 `std::fabs` 或 `std::isclose`（部分库有实现）









## 会议纪要

背景：

​	有三十台X86的工控机，硬件的pcie内部研发，和网卡的pcie和can的pcie都是外购的。

需求：

​	优化一下rover，需要落盘程序，需要去自测硬件。一月三十号交付。

问题:

​	缺少qt的相关库

目前方案：

​	bashrc设置永久环境变量。

​	优化部署流程，图标启动，安装时添加。



总结：

​	Qt打包成一个文件夹，  截止时间：  26号之前。   用清华2.0 分支。

​	笔记本： 轻薄本 linux。

​	bashrc设置永久环境变量。   26号解决。

​        有图标。支持图标启动。

​	

​	













