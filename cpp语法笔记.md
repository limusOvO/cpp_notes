# 1. 常规语法

## 1.1 `const`用法

### 1.1.1 修饰指针

* `const int* p` 或 `int const* p` → 指针指向的内容不可修改（pointer to const int）
* `int* const p` → 指针本身不可修改（const pointer to int）

```C++
const int* a = &x;       // [1] 指针指向内容不可修改，指针可改
int const* a = &x;       // [2] 同 [1]，内容不可改
int* const a = &x;       // [3] 指针不可改，内容可改
const int* const a = &x; // [4] 指针不可改，内容不可改
```

### 1.1.2 修饰函数

**成员函数后加` const`** → 表示该成员函数不会修改对象的成员变量（`this` 指针是 `const` 类型）。

**静态成员函数或非成员函数** → 不能在函数后加 `const`，因为它们没有 `this` 指针。

**特殊情况** → 成员变量如果要在` const `函数里修改，可加 `mutable` 修饰。

### 1.1.3 修饰返回值

- **返回类型前 `const`** → 修饰返回值
- **C++11 以后**：
  - `constexpr` → 编译期常量
  - `consteval` → 强制编译期求值（C++20）

### 1.1.4 修饰普通变量

定义不可修改的常量，提高代码安全性。

### 1.1.5 修饰函数参数

防止函数修改传入对象（尤其大对象用引用或指针传递时）



## 1.2 拷贝构造和赋值运算符

重点：

​	最本质的区别在于对象的状态。

​	拷贝构造函数是一个对象从无到有被创建（初始化）时调用的；

​	而赋值运算符是在两个都已经存在的对象之间，将一个对象的值赋值给另一个对象时调用的。

```C++
A a;
A b = a;  //调用拷贝构造（虽然是=号，但在初始化0
A c;
c = a; //调用赋值运算符（c已经存在）
```

面试回答方式：

	1. 拷贝构造用于对象初始化（T a = b ;), 对象此时还未分配资源。
	1. 赋值运算符用于修改已存在的对象的值（a = b); 对象此时可能已经持有资源。

在实现方面，有三个关键点我会注意下：

​	第一是自赋值检测： 在`operator=`中，首先要判断`&other!=this`,防止自身资源后再去拷贝，导致未定义行为。

​	第二是返回值： 赋值运算符应该返回*this的引用，已支持a = b = c 这样的链式调用。

​	第三是资源管理：如果我需要手动管理资源（如new/delete），我通常会同时实现拷贝构造、赋值运算和析构函数。在现代C++中，使用Copy-and-Swap（拷贝并交换）技术来实现赋值，这样能更好的保证异常安全。



补充： Copy-and-Swap 即利用拷贝构造函数创建一个临时副本，然后将副本与当前对象（*this）的数据进行swap， 这样利用了栈对象的析构函数自动处理资源释放，简洁又安全。 



## 1.3 深拷贝和浅拷贝



## 1.4 虚函数，多态，`vtable`(虚函数表)

C++的多态分为静态多态（编译时决定，如函数重载和模板）和动态多态（运行时决定）。 虚函数属于动态多态，它允许通过基类的指针或引用来调用派生类的成员函数。

（然后讲解一下vtable和vptr的关系）

编译器会为每个拥有虚函数的类都创建一个虚函数表（vtable），这是一个存储类成员函数地址的数组。

而每个对象实例中，编译器会隐式添加一个指针，称为虚函数指针（ptr），它指向该类对应的vtable。

当我们通过基类指针调用虚函数时，程序会经过以下步骤：

	1. 根据对象的vptr找到类的vtable
	1. 根据函数在表中的偏移量（offset）找到具体的函数地址。
	1. 跳转到该地址执行代码。

内存布局上：

​	一个含有虚函数的类，其对象会比普通类多出一个指针的大小（64位上是8字节），通常这个vptr位于对象内存布局的最前端（或者最后端，取决编译器实现），以便快速寻址。

多态的代价：

1.   空间开销：每个类一个vtable， 每个对象一个vptr
2.   时间开销： 多了一个指针间接寻址的开销；同时由于是运行时跳转，编译器很难对虚函数进行内联优化，这在高性能场景下是一个考虑因素。

面试回答：

​	C++的动态多态主要通过虚函数表和虚函数指针来实现。

​	简单来说，当一个类声明了虚函数，编译器就会为了这个类声称一张vtable，里面按顺序存放着虚函数的地址。当子类重写了父类的虚函数时，子类vtable中对应位置的地址就会被替换为子类函数的地址。

​	在实例化对象时，每个对象头部会自动包含一个vptr，当我们通过基类指针调用函数时，系统不会在编译时硬编码跳转地址，而是在运行时通过vptr找到vtable，再根据索引取出真正的函数地址进行调用。

​	这种机制实现的“延迟绑定”，但也会带来一些额外开销，比如vptr的占用空间以及无法内联导致的时间损耗，此外在多重继承下，一个对象可能有多个vptr，对应的布局也会更加复杂。



补充：	

​	构造函数可以是虚函数吗？（不可以，因为构造时vptr还没有初始化完成）

​	析构函数为什么要设置为虚函数？（防止基类指针指向子类对象时，析构只释放基类部分导致内存泄漏。）

​	虚函数表是每个对象一份吗？（不是，是每个类一份，所有对象共享同一张表，但是每个对象有自己的指针）

​	

## 1.5 内存管理 `new/delete` 与 `malloc` 与 `free`的区别

1.   主要区别是对象生命周期的管理。

​		new在分配内存后，会自动调用对象的构造函数进行初始化；而delete在释放内存前，会自动调用析构函数。

​		malloc和free仅仅是单纯的内存分配与释放，不会执行任何初始化或清理代码。

2.   类型安全与返回类型：

​		new是类型安全的，返回的是具体类型的指针，不需要显示强转。

​		而malloc返回的是void * ，在C++中必须进行强制强制类型转换。此外，new不需要手动计算内存的大小（编译器会根据类		型自动推导），而malloc需要手动传入sizeof（T）



## 1.6 左值与右值， 左值引用与右值引用



## 1.7 Lambda 捕获方式 `[=]` `[&]`



## 1.8 移动语义 vs 拷贝语义



## 1.9 智能指针  `unique_ptr / shared_ptr/weak_ptr`



## 1.10 override / final



## 1.11 explicit 防隐式类型转换





## 1.12 `constexpr` 函数增强



## 1.13 std::optional / std::variant / std::any



## 1.14 `inline` 全局变量



## 1.15 结构化绑定





## 1.15 string_view vs string





## 1.16` [[nodiscard]]`





##  1.17 fold 表达式





## 1.18 `if constexpr`



# 2. 编程规范

## 2.1 类型安全

 **程序在编译期或运行期尽量保证数据类型不被误用或意外转换**

``` c++
int a = 10;
double b = 3.14;

a = b; // 隐式转换，可能丢失精度 → 不完全类型安全
```

**C++ 类型安全机制：**

- **强类型检查**：C++ 不允许把指针随意赋值给其他类型（需要显式转换）。
- **const 修饰**：防止修改不该修改的类型数据。
- **enum class**（C++11）：强类型枚举，不允许隐式转 int。

```c++
enum Color { RED, GREEN, BLUE }; 		// 老式 enum，可以隐式转 int
enum class Color2 { RED, GREEN, BLUE }; // 类型安全，不可隐式转 int
```



## 2.2 浮点数比较的特殊方法

浮点数（`float` / `double`）存在精度问题，不宜直接用 `==` 比较：

```
double a = 0.1 + 0.2;
double b = 0.3;

if (a == b) { /* 不可靠 */ }
```

### 正确做法：使用 **误差范围 epsilon**

```
#include <cmath>
const double EPSILON = 1e-9;

if (std::abs(a - b) < EPSILON) {
    // a 与 b 可认为相等
}
```

- EPSILON 表示容忍的最小误差
- 对浮点数比较要使用绝对误差或者相对误差
- C++17 可以用 `std::fabs` 或 `std::isclose`（部分库有实现）

